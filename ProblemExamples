This document describes some problems tackled by spatial crowdsourcing system (SCS) and how the 
generic architecture is capable of supporting their solutions. 

----

Problem: 
Allow someone to find service providers to perform tasks in certain places (e.g., house cleaning, gardening)

Possible solution supported:
1. A instance of a SCS based on the architecture, allows workers (service providers) and requesters (a person 
in need of a service) to register for an account on the system. [Worker Manager, Requester Manager].

2. Requesters are then capable of publishing spatial tasks [Task Life Cycle Manager, Task Manager].

3. The task is recommended to a worker. A worker is also able to search normally for tasks. 
[Matching Helper]

3. The requester choose the best offer, and pay the system for it. [Task Life Cycle Manager, Payment System]

4. After the task is accomplished in the real world, the requester informs the system and rate the service 
[Task Life Cycle Manager, Task Manager].

5. The system pays the worker [Payment System]

----

Problem: 
A person, or an entity, wants to receive a report with data from a variety of sensors from volunteers inside a 
region within a specific time window.

Possible solution supported:
1. A instance of a SCS based on the architecture, allows workers (volunteers owners of rich sensor mobile devices) 
and requesters (a person or entity in need of the report) to register for an account on the system 
[Worker Manager, Requester Manager].

2. Requesters are then capable of publishing spatial tasks defining a region and a time window
[Task Life Cycle Manager, Task Manager].

3. Workers inside that region within the time window are assigned to the task [Matching Helper, Task Life Cycle Manager]. 

4. The workers' mobile devices start capturing data from their sensors and uploading it [Context Acquisition Layer]

5. At the end of the time window, the system compiles all captured results and send it to the requester 
[Task Life Cycle Manager, Quality Controller].

6. The task is considered finished [Task Life Cycle Manager].

----

Problem:
A driver wants to share the places in his car and the cost of a travel with others. Riders want to find a driver going
to the same destination in a suitable date.

Possible solution, based on BlaBlaCar:
1. A instance of a SCS based on the architecture, allows workers (drivers) 
and requesters (riders) to register for an account on the system 
[Worker Manager, Requester Manager].

2. Workers are capable of publishing spatial tasks (representing services their offer). Such tasks must define, along
other information, the origin (location of the task) and destination of the travel
[Task Life Cycle Manager, Task Manager].

3. The task is recommended to a requester. A requester is also able to search normally for tasks. 
[Matching Helper]

4. Requesters propose to travel with the worker [Task Life Cycle Manager, Task Manager].

5. The worker accepts the requesters. [Task Life Cycle Manager, Task Manager].

6. Requesters pay the system for the travel [Payment System].

4. After the riding is successfully accomplished, the requesters inform the system 
[Task Life Cycle Manager, Task Manager].

5. The system pays the worker [Payment System].

* Note that, here, we consider the worker is also capable of publishing a "task". In fact, many systems, 
(e.g., BlaBlaCar, AirTasker) make no distinction between workers and requester. This behavior does not change
the architecture proposed here, since it is easy to reproduce this behavior by considering a worker to
be also a requester and vice versa.  

* In this scenario, it would sound more natural to call a task a service. Thus, workers would publish services
they offer. However, we adopt the term task in the architecture because it is the most commonly adopted in 
the literature and industry.